<?php

declare(strict_types=1);

namespace DDr1nk\PhpstanHtmlOutputFormatter;

use DateTimeImmutable;
use PHPStan\Analyser\Error;
use PHPStan\Command\AnalysisResult;
use PHPStan\Command\ErrorFormatter\ErrorFormatter;
use PHPStan\Command\Output;
use Smarty\Smarty;

final class HtmlErrorFormatter implements ErrorFormatter
{
    private ?string $level;
    private ?string $outputDir;

    public function __construct(?string $level = null, ?string $outputDir = null)
    {
        $this->level = $level;
        $this->outputDir = $outputDir;
    }

    public function formatErrors(AnalysisResult $analysisResult, Output $output): int
    {
        $fileErrors = $analysisResult->getFileSpecificErrors();
        $notFileErrors = $analysisResult->getNotFileSpecificErrors();
        $internalErrors = $analysisResult->getInternalErrorObjects();
        $warnings = $analysisResult->getWarnings();

        $errorsByFile = [];
        $errorTypeCounts = [];
        foreach ($fileErrors as $error) {
            $file = $error->getFile();
            $errorsByFile[$file][] = $error;

            $identifier = $error->getIdentifier();
            $typeKey = $identifier !== null ? $identifier : 'general';
            $errorTypeCounts[$typeKey] = ($errorTypeCounts[$typeKey] ?? 0) + 1;
        }
        foreach ($notFileErrors as $error) {
            $identifier = $error->getIdentifier();
            $typeKey = $identifier !== null ? $identifier : 'general';
            $errorTypeCounts[$typeKey] = ($errorTypeCounts[$typeKey] ?? 0) + 1;
        }
        ksort($errorsByFile, SORT_STRING);
        arsort($errorTypeCounts);

        $filesByErrorCount = $errorsByFile;
        uasort($filesByErrorCount, static function (array $a, array $b): int {
            return count($b) <=> count($a);
        });

        $totalErrors = $analysisResult->getTotalErrorsCount();
        $totalFilesWithErrors = count($errorsByFile);
        $errorTypeLabels = array_map(static function (string $type): string {
            return $type === 'general' ? 'General' : $type;
        }, array_keys($errorTypeCounts));
        $errorTypeData = array_values($errorTypeCounts);

        $errorsByFileView = [];
        foreach ($errorsByFile as $file => $errors) {
            $items = [];
            foreach ($errors as $error) {
                $items[] = [
                    'line' => $error->getLine(),
                    'identifier' => $error->getIdentifier(),
                    'message' => $error->getMessage(),
                    'tip' => $error->getTip(),
                    'search' => $this->buildSearchString($error),
                ];
            }
            $errorsByFileView[] = [
                'file' => $file,
                'fileKey' => strtolower($file),
                'count' => count($errors),
                'errors' => $items,
            ];
        }

        $notFileErrorsView = [];
        foreach ($notFileErrors as $error) {
            $notFileErrorsView[] = [
                'line' => $error->getLine(),
                'identifier' => $error->getIdentifier(),
                'message' => $error->getMessage(),
                'tip' => $error->getTip(),
            ];
        }

        $internalErrorsView = [];
        foreach ($internalErrors as $internalError) {
            $internalErrorsView[] = [
                'message' => $internalError->getMessage(),
                'context' => $internalError->getContextDescription(),
            ];
        }

        $filesByErrorCountView = [];
        foreach ($filesByErrorCount as $file => $errors) {
            $filesByErrorCountView[] = [
                'file' => $file,
                'count' => count($errors),
            ];
        }

        $generatedAt = new DateTimeImmutable();
        $smarty = $this->createSmarty();
        $smarty->assign([
            'title' => 'PHPStan Report',
            'subtitle' => 'Generated by phpstan-html-output-formatter',
            'levelLabel' => $this->level !== null ? (string) $this->level : 'not determined',
            'generatedAt' => $generatedAt->format('Y-m-d H:i:s'),
            'totalErrors' => $totalErrors,
            'totalFilesWithErrors' => $totalFilesWithErrors,
            'warnings' => $warnings,
            'warningsCount' => count($warnings),
            'internalErrors' => $internalErrorsView,
            'internalErrorsCount' => count($internalErrors),
            'errorTypeCounts' => $errorTypeCounts,
            'errorTypeLabelsJson' => $this->encodeJson($errorTypeLabels),
            'errorTypeDataJson' => $this->encodeJson($errorTypeData),
            'filesByErrorCount' => $filesByErrorCountView,
            'errorsByFile' => $errorsByFileView,
            'notFileErrors' => $notFileErrorsView,
        ]);

        $html = $smarty->fetch('layout.tpl');

        $this->writeReportToDir($html, $generatedAt);
        $output->writeRaw($html);

        return $analysisResult->hasErrors() || $analysisResult->hasInternalErrors() ? 1 : 0;
    }

    private function buildSearchString(Error $error): string
    {
        $line = $error->getLine();
        $identifier = $error->getIdentifier();
        $tip = $error->getTip();
        $searchParts = [
            $error->getFile() ?? '',
            $line !== null ? (string) $line : '',
            $identifier ?? '',
            $error->getMessage(),
            $tip ?? '',
        ];

        return strtolower(trim(implode(' ', $searchParts)));
    }

    /**
     * @param array<mixed> $value
     */
    private function encodeJson(array $value): string
    {
        return json_encode($value, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_THROW_ON_ERROR);
    }

    private function createSmarty(): Smarty
    {
        $smarty = new Smarty();
        $smarty->setTemplateDir($this->templateDir());
        $smarty->setCompileDir($this->ensureDir($this->cacheBaseDir() . '/templates_c'));
        $smarty->setCacheDir($this->ensureDir($this->cacheBaseDir() . '/cache'));
        $smarty->escape_html = true;
        $smarty->setCaching(false);
        $smarty->setCompileCheck(true);

        return $smarty;
    }

    private function templateDir(): string
    {
        return dirname(__DIR__) . '/templates';
    }

    private function cacheBaseDir(): string
    {
        return rtrim(sys_get_temp_dir(), '/\\') . '/phpstan-html-output-formatter';
    }

    private function ensureDir(string $path): string
    {
        if (!is_dir($path)) {
            mkdir($path, 0777, true);
        }

        return $path;
    }

    private function writeReportToDir(string $html, DateTimeImmutable $generatedAt): void
    {
        if ($this->outputDir === null || trim($this->outputDir) === '') {
            return;
        }

        $dir = $this->ensureDir($this->outputDir);
        $fileName = 'phpstan-report-' . $generatedAt->format('Ymd-His') . '.html';
        $path = rtrim($dir, '/\\') . DIRECTORY_SEPARATOR . $fileName;
        file_put_contents($path, $html);
    }
}
